<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Penguin Rush - On-Chain Game | RISE Testnet</title>
    <meta name="description" content="Every jump is a transaction! Play Penguin Rush on RISE Chain with 3ms confirmations.">
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: linear-gradient(135deg, #0a1628 0%, #1a2a4a 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', system-ui, sans-serif;
            color: white;
            overflow-x: hidden;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 20px;
            font-weight: bold;
        }
        
        .logo span { color: #4fc3f7; }
        
        .chain-badge {
            background: linear-gradient(135deg, #7c3aed, #4f46e5);
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .chain-badge .dot {
            width: 8px;
            height: 8px;
            background: #4ade80;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .connect-btn {
            background: linear-gradient(135deg, #a855f7 0%, #7c3aed 100%);
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            color: white;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .connect-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(168,85,247,0.4);
        }
        
        .connect-btn.connected {
            background: linear-gradient(135deg, #4ade80, #22c55e);
        }
        
        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            gap: 20px;
        }
        
        .game-wrapper {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .game-container {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5), 0 0 40px rgba(100,200,255,0.2);
        }
        
        canvas { display: block; cursor: pointer; }
        
        .ui-overlay {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
        }
        
        .score-display, .distance-display {
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .score-display span, .distance-display span { color: #4fc3f7; }
        
        .side-panel {
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .panel-card {
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .panel-card h3 {
            font-size: 14px;
            color: #90caf9;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        .stat-item {
            background: rgba(0,0,0,0.3);
            padding: 12px;
            border-radius: 10px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4fc3f7;
        }
        
        .stat-label {
            font-size: 11px;
            color: #90caf9;
            margin-top: 4px;
        }
        
        .tx-log {
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 11px;
        }
        
        .tx-item {
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            margin-bottom: 8px;
            border-left: 3px solid #4fc3f7;
        }
        
        .tx-item.pending { border-left-color: #fbbf24; }
        .tx-item.success { border-left-color: #4ade80; }
        .tx-item.error { border-left-color: #ef4444; }
        
        .tx-hash {
            color: #4fc3f7;
            text-decoration: none;
            word-break: break-all;
        }
        
        .tx-hash:hover { text-decoration: underline; }
        
        .start-screen, .game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10,22,40,0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 20px;
        }
        
        .start-screen h1 {
            font-size: 36px;
            margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(79,195,247,0.8);
            color: #4fc3f7;
        }
        
        .start-screen .subtitle {
            font-size: 16px;
            color: #90caf9;
            margin-bottom: 20px;
        }
        
        .penguin-icon {
            font-size: 60px;
            margin-bottom: 15px;
            animation: bounce 1s ease-in-out infinite;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        .onchain-badge {
            background: linear-gradient(135deg, #7c3aed, #4f46e5);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            margin-bottom: 20px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        
        .instructions {
            background: rgba(255,255,255,0.1);
            padding: 15px 25px;
            border-radius: 12px;
            margin-bottom: 20px;
            max-width: 320px;
            text-align: left;
        }
        
        .instructions p {
            margin: 6px 0;
            font-size: 13px;
            color: #b3e5fc;
        }
        
        .instructions strong { color: #4fc3f7; }
        
        .play-btn {
            background: linear-gradient(135deg, #4fc3f7 0%, #29b6f6 100%);
            border: none;
            padding: 16px 40px;
            font-size: 18px;
            font-weight: bold;
            color: #0a1628;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 10px 30px rgba(79,195,247,0.4);
        }
        
        .play-btn:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(79,195,247,0.6);
        }
        
        .play-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .session-btn {
            background: linear-gradient(135deg, #a855f7 0%, #7c3aed 100%);
            border: none;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: bold;
            color: white;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
        }
        
        .session-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(168,85,247,0.4);
        }
        
        .session-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .game-over-screen h2 {
            font-size: 32px;
            color: #ef5350;
            margin-bottom: 15px;
        }
        
        .game-over-screen .final-score span {
            color: #4fc3f7;
            font-size: 32px;
        }
        
        .session-key-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            font-size: 12px;
        }
        
        .session-key-status .indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ef4444;
        }
        
        .session-key-status.active .indicator { background: #4ade80; }
        .session-key-status.session .indicator { background: #a855f7; animation: pulse 1s infinite; }
        
        .hidden { display: none !important; }
        
        .wallet-info {
            font-size: 12px;
            color: #90caf9;
            margin-top: 10px;
        }
        
        .wallet-address {
            font-family: monospace;
            color: #4fc3f7;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            margin-bottom: 6px;
            font-size: 12px;
        }
        
        .leaderboard-item .rank {
            color: #fbbf24;
            font-weight: bold;
            min-width: 25px;
        }
        
        .leaderboard-item .address {
            font-family: monospace;
            color: #90caf9;
        }
        
        .leaderboard-item .score {
            color: #4fc3f7;
            font-weight: bold;
        }

        .global-stats {
            display: flex;
            justify-content: space-around;
            text-align: center;
            padding-top: 10px;
            border-top: 1px solid rgba(255,255,255,0.1);
            margin-top: 10px;
        }

        .global-stat { font-size: 11px; }

        .global-stat .value {
            font-size: 18px;
            font-weight: bold;
            color: #4fc3f7;
        }
        
        .rise-wallet-badge {
            background: linear-gradient(135deg, #a855f7, #7c3aed);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 10px;
            margin-left: 8px;
        }
        
        .loading-indicator {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">üêß <span>Penguin Rush</span></div>
        <div class="chain-badge">
            <span class="dot"></span>
            RISE Testnet
        </div>
        <button class="connect-btn" id="connectBtn">
            üîê Connect RISE Wallet
        </button>
    </header>

    <main class="main-container">
        <div class="game-wrapper">
            <div class="game-container">
                <canvas id="gameCanvas" width="700" height="450"></canvas>
                <div class="ui-overlay">
                    <div class="score-display">‚≠ê Score: <span id="score">0</span></div>
                    <div class="distance-display">üèîÔ∏è <span id="distance">500</span>m</div>
                </div>
                
                <div class="start-screen" id="startScreen">
                    <div class="penguin-icon">üêß</div>
                    <h1>PENGUIN RUSH</h1>
                    <div class="onchain-badge">‚õìÔ∏è Every Jump = 1 Transaction</div>
                    <p class="subtitle">On-Chain Game on RISE Testnet</p>
                    
                    <div class="instructions">
                        <p><strong>üéØ Goal:</strong> Jump to the mountain!</p>
                        <p><strong>üñ±Ô∏è Click/Space:</strong> Jump (sends TX)</p>
                        <p><strong>‚ö° RISE:</strong> 3ms confirmations!</p>
                        <p><strong>üîê RISE Wallet:</strong> Passkey login!</p>
                        <p><strong>üîë Session Key:</strong> No popups per jump!</p>
                    </div>
                    <div id="walletStatus" class="wallet-info">
                        Connect RISE Wallet to play on-chain
                    </div>
                    <button class="play-btn" id="startBtn" disabled>
                        Connect Wallet First
                    </button>
                    <button class="session-btn hidden" id="sessionBtn">
                        üîë Create Session Key (1 hour)
                    </button>
                </div>
                
                <div class="game-over-screen hidden" id="gameOverScreen">
                    <div class="penguin-icon">üò¢</div>
                    <h2>SPLASH!</h2>
                    <p class="final-score">Score: <span id="finalScore">0</span></p>
                    <p id="finalJumps" style="color: #90caf9; margin: 10px 0;">0 jumps recorded on-chain</p>
                    <p id="txConfirmed" style="color: #4ade80; font-size: 12px; margin-bottom: 20px;"></p>
                    <button class="play-btn" id="playAgainBtn">üîÑ Play Again</button>
                </div>
            </div>
            
            <div class="side-panel">
                <div class="panel-card">
                    <h3>‚õìÔ∏è On-Chain Status</h3>
                    <div class="session-key-status" id="sessionStatus">
                        <span class="indicator"></span>
                        <span id="sessionText">Not Connected</span>
                    </div>
                    <div style="margin-top: 12px; font-size: 11px; color: #90caf9;">
                        Contract: <a href="https://explorer.testnet.riselabs.xyz/address/0x36057B9fe61Cf29e4cde42558f69c2b4269aB778" target="_blank" class="tx-hash">0x3605...B778</a>
                    </div>
                </div>
                
                <div class="panel-card">
                    <h3>üìä Your Stats</h3>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-value" id="statGames">0</div>
                            <div class="stat-label">Games</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="statJumps">0</div>
                            <div class="stat-label">Total Jumps</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="statHighScore">0</div>
                            <div class="stat-label">High Score</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="statMountains">0</div>
                            <div class="stat-label">üèîÔ∏è Reached</div>
                        </div>
                    </div>
                </div>
                
                <div class="panel-card">
                    <h3>üìú Transaction Log</h3>
                    <div class="tx-log" id="txLog">
                        <div style="color: #64748b; font-style: italic; padding: 10px;">
                            Transactions will appear here...
                        </div>
                    </div>
                </div>

                <div class="panel-card">
                    <h3>üèÜ Leaderboard</h3>
                    <div id="leaderboard">
                        <div style="color: #64748b; font-style: italic; padding: 10px; font-size: 12px;">
                            Connect to load leaderboard
                        </div>
                    </div>
                    <div class="global-stats" id="globalStats">
                        <div class="global-stat">
                            <div class="value" id="globalGames">-</div>
                            <div>Games</div>
                        </div>
                        <div class="global-stat">
                            <div class="value" id="globalJumps">-</div>
                            <div>Jumps</div>
                        </div>
                        <div class="global-stat">
                            <div class="value" id="globalPlayers">-</div>
                            <div>Players</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Use importmap to load RISE Wallet SDK -->
    <script type="importmap">
    {
        "imports": {
            "rise-wallet": "https://esm.sh/rise-wallet@0.3.2",
            "rise-wallet/viem": "https://esm.sh/rise-wallet@0.3.2/viem",
            "viem": "https://esm.sh/viem@2.37.0",
            "viem/actions": "https://esm.sh/viem@2.37.0/actions",
            "ox": "https://esm.sh/ox@0.6.0"
        }
    }
    </script>

    <script type="module">
        // ============ CONFIG ============
        const CONTRACT_ADDRESS = '0x36057B9fe61Cf29e4cde42558f69c2b4269aB778';
        const RISE_CHAIN_ID = 11155931;
        const RISE_CHAIN_ID_HEX = '0xAA39DB';
        const RPC_URL = 'https://testnet.riselabs.xyz';
        const EXPLORER_URL = 'https://explorer.testnet.riselabs.xyz';
        
        const CONTRACT_ABI = [
            {
                name: 'startGame',
                type: 'function',
                inputs: [],
                outputs: [],
                stateMutability: 'nonpayable'
            },
            {
                name: 'jump',
                type: 'function',
                inputs: [{ name: 'landedOnIceberg', type: 'bool' }],
                outputs: [],
                stateMutability: 'nonpayable'
            },
            {
                name: 'endGame',
                type: 'function',
                inputs: [],
                outputs: [],
                stateMutability: 'nonpayable'
            },
            {
                name: 'getPlayerStats',
                type: 'function',
                inputs: [{ name: 'player', type: 'address' }],
                outputs: [
                    { name: 'totalGames', type: 'uint256' },
                    { name: 'totalJumps', type: 'uint256' },
                    { name: 'highScore', type: 'uint256' },
                    { name: 'bestDistance', type: 'uint256' },
                    { name: 'mountainReaches', type: 'uint256' }
                ],
                stateMutability: 'view'
            },
            {
                name: 'getLeaderboard',
                type: 'function',
                inputs: [{ name: 'count', type: 'uint256' }],
                outputs: [
                    { name: 'players', type: 'address[]' },
                    { name: 'scores', type: 'uint256[]' }
                ],
                stateMutability: 'view'
            },
            {
                name: 'getGlobalStats',
                type: 'function',
                inputs: [],
                outputs: [
                    { name: 'totalGames', type: 'uint256' },
                    { name: 'totalJumps', type: 'uint256' },
                    { name: 'totalPlayers', type: 'uint256' }
                ],
                stateMutability: 'view'
            }
        ];
        
        // Function selectors for session key permissions
        const FUNCTION_SELECTORS = {
            startGame: '0xd65ab5f2',
            jump: '0x82a9eb50', 
            endGame: '0xab095a1f'
        };

        // ============ STATE ============
        let riseWallet = null;
        let riseClient = null;
        let userAddress = null;
        let gameRunning = false;
        let pendingTxCount = 0;
        let confirmedTxCount = 0;
        let hasSessionKey = false;
        let sessionKeyData = null;

        // ============ RISE WALLET INIT ============
        async function initRiseWallet() {
            try {
                addTxLog('Loading RISE Wallet SDK...', 'pending');
                
                const riseWalletModule = await import('rise-wallet');
                const { RiseWallet, Chains } = riseWalletModule;
                const { createClient, custom, http } = await import('viem');
                const riseViem = await import('rise-wallet/viem');
                
                // Store for later use - functions are under WalletActions namespace
                window.riseModules = { 
                    RiseWallet, 
                    Chains,
                    createClient, 
                    custom, 
                    http, 
                    Key: riseViem.Key,
                    WalletActions: riseViem.WalletActions
                };
                
                // Use the SDK's built-in RISE Testnet chain configuration
                const riseTestnet = Chains.riseTestnet;
                console.log('Using chain:', riseTestnet);
                
                riseWallet = RiseWallet.create({
                    chains: [riseTestnet]
                });
                
                // Create viem client with RISE Wallet provider
                riseClient = createClient({
                    transport: custom(riseWallet.provider)
                });
                
                addTxLog('RISE Wallet SDK loaded!', 'success');
                return true;
                
            } catch (error) {
                console.error('RISE Wallet init error:', error);
                addTxLog('SDK load failed: ' + error.message, 'error');
                return false;
            }
        }

        // ============ CONNECT WALLET ============
        async function connectWallet() {
            const connectBtn = document.getElementById('connectBtn');
            connectBtn.innerHTML = '<span class="loading-indicator"></span> Connecting...';
            
            try {
                if (!riseWallet) {
                    const loaded = await initRiseWallet();
                    if (!loaded) {
                        throw new Error('Failed to load RISE Wallet SDK');
                    }
                }
                
                const { WalletActions } = window.riseModules;
                
                addTxLog('Opening RISE Wallet...', 'pending');
                
                // Connect using RISE Wallet (opens dialog/iframe)
                const result = await WalletActions.connect(riseClient);
                console.log('Connect result:', result);
                console.log('Result keys:', Object.keys(result || {}));
                
                // Handle different response structures
                userAddress = result?.accounts?.[0] || result?.address || result?.[0];
                
                if (!userAddress) {
                    console.error('Full result:', JSON.stringify(result, null, 2));
                    throw new Error('No account returned. Result: ' + JSON.stringify(result));
                }
                
                updateConnectedUI();
                addTxLog('Connected: ' + userAddress.slice(0, 10) + '...', 'success');
                
                // Show session key button
                document.getElementById('sessionBtn').classList.remove('hidden');
                
                await loadPlayerStats();
                await loadLeaderboard();
                await loadGlobalStats();
                
            } catch (error) {
                console.error('Connection error:', error);
                console.error('Error stack:', error.stack);
                addTxLog('Connection failed: ' + (error.message || error), 'error');
                connectBtn.innerHTML = 'üîê Connect RISE Wallet';
            }
        }
        
        function updateConnectedUI() {
            const connectBtn = document.getElementById('connectBtn');
            const shortAddr = userAddress.slice(0, 6) + '...' + userAddress.slice(-4);
            
            connectBtn.innerHTML = `üîê ${shortAddr} <span class="rise-wallet-badge">RISE</span>`;
            connectBtn.classList.add('connected');
            
            document.getElementById('walletStatus').innerHTML = 
                `Connected: <span class="wallet-address">${shortAddr}</span>`;
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('startBtn').textContent = 'üöÄ START GAME';

            document.getElementById('sessionStatus').classList.add('active');
            document.getElementById('sessionText').textContent = 'RISE Wallet Connected';
        }

        // ============ SESSION KEY CREATION ============
        async function createSessionKey() {
            if (!riseClient || !userAddress) {
                addTxLog('Connect wallet first', 'error');
                return;
            }
            
            const sessionBtn = document.getElementById('sessionBtn');
            sessionBtn.innerHTML = '<span class="loading-indicator"></span> Creating...';
            sessionBtn.disabled = true;
            
            try {
                const { Key, WalletActions } = window.riseModules;
                const { P256, PublicKey, Hex } = await import('ox');
                
                addTxLog('Creating session key...', 'pending');
                
                // Generate a new P256 key pair
                const privateKey = P256.randomPrivateKey();
                const publicKey = PublicKey.toHex(P256.getPublicKey({ privateKey }), {
                    includePrefix: false
                });
                
                // Define permissions for game contract
                const permissions = {
                    calls: [
                        { to: CONTRACT_ADDRESS, signature: FUNCTION_SELECTORS.startGame },
                        { to: CONTRACT_ADDRESS, signature: FUNCTION_SELECTORS.jump },
                        { to: CONTRACT_ADDRESS, signature: FUNCTION_SELECTORS.endGame }
                    ]
                };
                
                // Grant permissions (1 hour expiry)
                const expiry = Math.floor(Date.now() / 1000) + 3600;
                
                await WalletActions.grantPermissions(riseClient, {
                    key: { publicKey, type: 'p256' },
                    expiry,
                    permissions
                });
                
                // Store session key data
                sessionKeyData = {
                    privateKey,
                    publicKey,
                    expiry
                };
                
                // Save to localStorage for persistence
                localStorage.setItem('penguinRush_sessionKey', JSON.stringify({
                    privateKey: Hex.fromBytes(privateKey),
                    publicKey,
                    expiry
                }));
                
                hasSessionKey = true;
                document.getElementById('sessionStatus').classList.add('session');
                document.getElementById('sessionText').textContent = 'üîë Session Key Active (1hr)';
                sessionBtn.textContent = '‚úì Session Key Active';
                
                addTxLog('Session key created! Jumps will be signed automatically.', 'success');
                
            } catch (error) {
                console.error('Session key error:', error);
                addTxLog('Session key failed: ' + error.message, 'error');
                sessionBtn.innerHTML = 'üîë Create Session Key (1 hour)';
                sessionBtn.disabled = false;
            }
        }

        // ============ CONTRACT INTERACTIONS ============
        async function sendGameTx(functionName, args = []) {
            if (!riseClient || !userAddress) return null;

            try {
                pendingTxCount++;
                addTxLog(`${functionName}() pending...`, 'pending');

                const { encodeFunctionData } = await import('viem');
                
                // Find the function in ABI
                const funcAbi = CONTRACT_ABI.find(f => f.name === functionName);
                if (!funcAbi) throw new Error('Function not found in ABI');
                
                // Encode the function call
                const data = encodeFunctionData({
                    abi: [funcAbi],
                    functionName,
                    args
                });
                
                let hash;
                
                // If we have a session key, use it for popup-free signing
                if (hasSessionKey && sessionKeyData) {
                    try {
                        hash = await executeWithSessionKey([{
                            to: CONTRACT_ADDRESS,
                            data,
                            value: 0n
                        }]);
                    } catch (sessionError) {
                        console.log('Session key tx failed, falling back:', sessionError);
                        // Fall through to normal tx
                        hash = null;
                    }
                }
                
                // Normal transaction (with popup) if no session key or session failed
                if (!hash) {
                    const { sendTransaction } = await import('viem/actions');
                    hash = await sendTransaction(riseClient, {
                        account: userAddress,
                        to: CONTRACT_ADDRESS,
                        data
                    });
                }
                
                addTxLog(`${functionName}() sent: ${hash.slice(0, 10)}...`, 'pending', hash);

                // Don't wait for receipt during gameplay to keep it fast
                // Just fire and forget, update log when confirmed
                waitForTx(hash, functionName);

                return hash;
            } catch (error) {
                pendingTxCount--;
                const errMsg = error.message || 'Unknown error';
                addTxLog(`${functionName}() failed: ${errMsg.slice(0, 40)}`, 'error');
                console.error('TX Error:', error);
                return null;
            }
        }
        
        async function executeWithSessionKey(calls) {
            const { P256, Signature, Hex, PublicKey } = await import('ox');
            
            const publicKey = sessionKeyData.publicKey;
            
            // Prepare the calls
            const prepareResult = await riseWallet.provider.request({
                method: 'wallet_prepareCalls',
                params: [{
                    calls,
                    chainId: Hex.fromNumber(RISE_CHAIN_ID),
                    from: userAddress,
                    atomicRequired: true,
                    key: {
                        publicKey,
                        type: 'p256'
                    }
                }]
            });
            
            const { digest, capabilities, ...request } = prepareResult;
            
            // Sign the digest with session key
            const signature = Signature.toHex(
                P256.sign({
                    payload: digest,
                    privateKey: sessionKeyData.privateKey
                })
            );
            
            // Send prepared calls
            const result = await riseWallet.provider.request({
                method: 'wallet_sendPreparedCalls',
                params: [{
                    ...request,
                    ...(capabilities ? { capabilities } : {}),
                    signature
                }]
            });
            
            return result[0] || result;
        }
        
        async function waitForTx(hash, functionName) {
            try {
                const { waitForTransactionReceipt } = await import('viem/actions');
                const { createPublicClient, http } = await import('viem');
                
                const publicClient = createPublicClient({
                    transport: http(RPC_URL)
                });
                
                await publicClient.waitForTransactionReceipt({ hash });
                confirmedTxCount++;
                pendingTxCount--;
                updateTxLog(hash, 'success');
            } catch (e) {
                console.error('Wait for tx error:', e);
            }
        }

        async function loadPlayerStats() {
            if (!userAddress) return;

            try {
                const { readContract } = await import('viem/actions');
                const { createPublicClient, http } = await import('viem');
                
                const publicClient = createPublicClient({
                    transport: http(RPC_URL)
                });
                
                const funcAbi = CONTRACT_ABI.find(f => f.name === 'getPlayerStats');
                
                const stats = await publicClient.readContract({
                    address: CONTRACT_ADDRESS,
                    abi: [funcAbi],
                    functionName: 'getPlayerStats',
                    args: [userAddress]
                });
                
                document.getElementById('statGames').textContent = stats[0].toString();
                document.getElementById('statJumps').textContent = stats[1].toString();
                document.getElementById('statHighScore').textContent = stats[2].toString();
                document.getElementById('statMountains').textContent = stats[4].toString();
            } catch (e) {
                console.error('Failed to load stats:', e);
            }
        }

        async function loadLeaderboard() {
            try {
                const { readContract } = await import('viem/actions');
                const { createPublicClient, http } = await import('viem');
                
                const publicClient = createPublicClient({
                    transport: http(RPC_URL)
                });
                
                const funcAbi = CONTRACT_ABI.find(f => f.name === 'getLeaderboard');
                
                const [players, scores] = await publicClient.readContract({
                    address: CONTRACT_ADDRESS,
                    abi: [funcAbi],
                    functionName: 'getLeaderboard',
                    args: [5n]
                });
                
                const container = document.getElementById('leaderboard');
                
                if (players.length === 0) {
                    container.innerHTML = '<div style="color: #64748b; font-style: italic; padding: 10px; font-size: 12px;">No players yet - be the first!</div>';
                    return;
                }

                container.innerHTML = players.map((addr, i) => `
                    <div class="leaderboard-item">
                        <span class="rank">#${i + 1}</span>
                        <span class="address">${addr.slice(0, 6)}...${addr.slice(-4)}</span>
                        <span class="score">${scores[i].toString()}</span>
                    </div>
                `).join('');
            } catch (e) {
                console.error('Failed to load leaderboard:', e);
            }
        }

        async function loadGlobalStats() {
            try {
                const { readContract } = await import('viem/actions');
                const { createPublicClient, http } = await import('viem');
                
                const publicClient = createPublicClient({
                    transport: http(RPC_URL)
                });
                
                const funcAbi = CONTRACT_ABI.find(f => f.name === 'getGlobalStats');
                
                const [totalGames, totalJumps, totalPlayers] = await publicClient.readContract({
                    address: CONTRACT_ADDRESS,
                    abi: [funcAbi],
                    functionName: 'getGlobalStats'
                });
                
                document.getElementById('globalGames').textContent = totalGames.toString();
                document.getElementById('globalJumps').textContent = totalJumps.toString();
                document.getElementById('globalPlayers').textContent = totalPlayers.toString();
            } catch (e) {
                console.error('Failed to load global stats:', e);
            }
        }

        // ============ TX LOG ============
        function addTxLog(message, status, hash = null) {
            const log = document.getElementById('txLog');
            const item = document.createElement('div');
            item.className = `tx-item ${status}`;
            item.id = hash ? `tx-${hash}` : `tx-${Date.now()}`;
            
            if (hash) {
                item.innerHTML = `<a href="${EXPLORER_URL}/tx/${hash}" target="_blank" class="tx-hash">${message}</a>`;
            } else {
                item.textContent = message;
            }
            
            if (log.children.length === 1 && log.children[0].style.fontStyle === 'italic') {
                log.innerHTML = '';
            }
            
            log.insertBefore(item, log.firstChild);
            
            while (log.children.length > 20) {
                log.removeChild(log.lastChild);
            }
        }

        function updateTxLog(hash, status) {
            const item = document.getElementById(`tx-${hash}`);
            if (item) {
                item.className = `tx-item ${status}`;
            }
        }

        // ============ GAME ENGINE ============
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let score = 0;
        let distanceToMountain = 500;
        let gameSpeed = 5;
        let jumpCount = 0;
        
        let penguin = {
            x: 100, y: 280, width: 35, height: 45,
            velocityY: 0, isJumping: false, onIceberg: false, currentIceberg: null
        };
        
        let icebergs = [];
        let stars = [];
        let waveOffset = 0;
        let mountainX = 750;

        for (let i = 0; i < 40; i++) {
            stars.push({
                x: Math.random() * 700,
                y: Math.random() * 180,
                size: Math.random() * 2 + 1,
                twinkle: Math.random() * Math.PI * 2
            });
        }

        function createIceberg(x, y, width) {
            return {
                x, y, width: width || 70 + Math.random() * 50,
                height: 30, baseY: y,
                floatOffset: Math.random() * Math.PI * 2,
                floatSpeed: 0.03 + Math.random() * 0.02,
                driftDirection: Math.random() > 0.5 ? 1 : -1,
                driftSpeed: 0.3 + Math.random() * 0.4,
                scored: false
            };
        }

        function initGame() {
            penguin = { x: 100, y: 280, width: 35, height: 45, velocityY: 0, isJumping: false, onIceberg: false, currentIceberg: null };
            score = 0;
            distanceToMountain = 500;
            gameSpeed = 5;
            jumpCount = 0;
            confirmedTxCount = 0;
            mountainX = 750;
            
            icebergs = [createIceberg(70, 350, 100)];
            for (let i = 1; i < 5; i++) {
                icebergs.push(createIceberg(180 + i * 140 + Math.random() * 40, 320 + Math.random() * 70));
            }
            
            updateUI();
        }

        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('distance').textContent = Math.max(0, Math.floor(distanceToMountain));
        }

        function drawBackground() {
            const skyGrad = ctx.createLinearGradient(0, 0, 0, 320);
            skyGrad.addColorStop(0, '#0a1628');
            skyGrad.addColorStop(0.5, '#1a3a5c');
            skyGrad.addColorStop(1, '#2d5a7b');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, 700, 320);

            stars.forEach(s => {
                s.twinkle += 0.05;
                ctx.fillStyle = `rgba(255,255,255,${0.5 + Math.sin(s.twinkle) * 0.5})`;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                ctx.fill();
            });

            drawMountain();

            const waterGrad = ctx.createLinearGradient(0, 350, 0, 450);
            waterGrad.addColorStop(0, '#1565c0');
            waterGrad.addColorStop(1, '#0d47a1');
            ctx.fillStyle = waterGrad;
            ctx.fillRect(0, 350, 700, 100);

            waveOffset += 0.08;
            ctx.fillStyle = 'rgba(66, 165, 245, 0.4)';
            ctx.beginPath();
            ctx.moveTo(0, 360);
            for (let x = 0; x <= 700; x += 20) {
                ctx.lineTo(x, 355 + Math.sin(x * 0.02 + waveOffset) * 7);
            }
            ctx.lineTo(700, 450);
            ctx.lineTo(0, 450);
            ctx.closePath();
            ctx.fill();
        }

        function drawMountain() {
            const mx = mountainX;
            ctx.fillStyle = '#3d5a80';
            ctx.beginPath();
            ctx.moveTo(mx - 80, 350);
            ctx.lineTo(mx + 15, 140);
            ctx.lineTo(mx + 110, 350);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#4a6fa5';
            ctx.beginPath();
            ctx.moveTo(mx - 40, 350);
            ctx.lineTo(mx + 40, 170);
            ctx.lineTo(mx + 130, 350);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#e8f4f8';
            ctx.beginPath();
            ctx.moveTo(mx + 15, 170);
            ctx.lineTo(mx + 40, 170);
            ctx.lineTo(mx + 65, 205);
            ctx.lineTo(mx + 45, 215);
            ctx.lineTo(mx + 30, 198);
            ctx.lineTo(mx + 5, 215);
            ctx.lineTo(mx - 10, 198);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#ef5350';
            ctx.fillRect(mx + 38, 140, 3, 30);
            ctx.beginPath();
            ctx.moveTo(mx + 41, 140);
            ctx.lineTo(mx + 60, 148);
            ctx.lineTo(mx + 41, 156);
            ctx.closePath();
            ctx.fill();
        }

        function drawIceberg(b) {
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.ellipse(b.x + b.width/2, b.y + b.height + 4, b.width/2 + 4, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            const grad = ctx.createLinearGradient(b.x, b.y, b.x, b.y + b.height + 18);
            grad.addColorStop(0, '#e3f2fd');
            grad.addColorStop(0.3, '#bbdefb');
            grad.addColorStop(0.7, '#90caf9');
            grad.addColorStop(1, '#64b5f6');
            ctx.fillStyle = grad;
            
            ctx.beginPath();
            ctx.moveTo(b.x + 8, b.y);
            ctx.lineTo(b.x + b.width - 8, b.y);
            ctx.lineTo(b.x + b.width + 4, b.y + b.height);
            ctx.lineTo(b.x + b.width - 12, b.y + b.height + 18);
            ctx.lineTo(b.x + 12, b.y + b.height + 18);
            ctx.lineTo(b.x - 4, b.y + b.height);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.beginPath();
            ctx.moveTo(b.x + 12, b.y + 4);
            ctx.lineTo(b.x + 32, b.y + 4);
            ctx.lineTo(b.x + 28, b.y + 12);
            ctx.lineTo(b.x + 12, b.y + 12);
            ctx.closePath();
            ctx.fill();
        }

        function drawPenguin() {
            const px = penguin.x, py = penguin.y;

            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.ellipse(px + 17, py + 27, 15, 19, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#f5f5f5';
            ctx.beginPath();
            ctx.ellipse(px + 17, py + 29, 10, 14, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.arc(px + 17, py + 9, 12, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.ellipse(px + 12, py + 7, 4, 5, 0, 0, Math.PI * 2);
            ctx.ellipse(px + 22, py + 7, 4, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.arc(px + 13, py + 7, 2, 0, Math.PI * 2);
            ctx.arc(px + 23, py + 7, 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#ff9800';
            ctx.beginPath();
            ctx.moveTo(px + 17, py + 10);
            ctx.lineTo(px + 24, py + 14);
            ctx.lineTo(px + 17, py + 17);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.ellipse(px + 10, py + 44, 7, 3, -0.3, 0, Math.PI * 2);
            ctx.ellipse(px + 24, py + 44, 7, 3, 0.3, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#1a1a2e';
            const wingAngle = penguin.isJumping ? Math.sin(Date.now() / 50) * 0.5 : 0;
            ctx.save();
            ctx.translate(px + 4, py + 22);
            ctx.rotate(-0.3 + wingAngle);
            ctx.fillRect(-2, 0, 7, 17);
            ctx.restore();
            ctx.save();
            ctx.translate(px + 30, py + 22);
            ctx.rotate(0.3 - wingAngle);
            ctx.fillRect(-5, 0, 7, 17);
            ctx.restore();
        }

        async function jump() {
            if (!gameRunning) return;
            if (penguin.isJumping && !penguin.onIceberg) return;

            penguin.velocityY = -13;
            penguin.isJumping = true;
            const wasOnIceberg = penguin.onIceberg;
            penguin.onIceberg = false;
            penguin.currentIceberg = null;
            
            score += 5;
            jumpCount++;
            updateUI();

            sendGameTx('jump', [wasOnIceberg]);
        }

        function checkCollisions() {
            penguin.onIceberg = false;

            for (const berg of icebergs) {
                if (penguin.velocityY >= 0 &&
                    penguin.x + penguin.width > berg.x + 4 &&
                    penguin.x < berg.x + berg.width - 4 &&
                    penguin.y + penguin.height > berg.y &&
                    penguin.y + penguin.height < berg.y + 22) {
                    
                    penguin.y = berg.y - penguin.height;
                    penguin.velocityY = 0;
                    penguin.isJumping = false;
                    penguin.onIceberg = true;
                    penguin.currentIceberg = berg;

                    if (!berg.scored) {
                        score += 10;
                        berg.scored = true;
                        updateUI();
                    }
                    break;
                }
            }
        }

        function update() {
            if (!gameRunning) return;

            gameSpeed = Math.min(10, 5 + score / 150);

            penguin.velocityY += 0.55;
            penguin.y += penguin.velocityY;

            if (penguin.onIceberg && penguin.currentIceberg) {
                penguin.y = penguin.currentIceberg.y - penguin.height;
                penguin.x -= gameSpeed;
            }

            if (penguin.x < 40) penguin.x = 40;

            icebergs.forEach(b => {
                b.x -= gameSpeed;
                b.floatOffset += b.floatSpeed;
                b.y = b.baseY + Math.sin(b.floatOffset) * 7;
                b.baseY += b.driftDirection * b.driftSpeed * 0.25;
                if (b.baseY < 300) { b.baseY = 300; b.driftDirection = 1; }
                if (b.baseY > 370) { b.baseY = 370; b.driftDirection = -1; }
            });

            icebergs = icebergs.filter(b => b.x + b.width > -40);

            if (icebergs.length < 5) {
                const last = icebergs[icebergs.length - 1];
                const gap = 90 + Math.random() * 70;
                icebergs.push(createIceberg(last.x + last.width + gap, 310 + Math.random() * 55));
            }

            distanceToMountain -= gameSpeed * 0.1;
            mountainX -= gameSpeed * 0.25;
            updateUI();

            if (distanceToMountain <= 0) {
                gameRunning = false;
                score += 500;
                sendGameTx('endGame');
                alert('üéâ CONGRATULATIONS! You reached the mountain!\nFinal Score: ' + score + '\nJumps on-chain: ' + jumpCount);
                document.getElementById('startScreen').classList.remove('hidden');
                loadPlayerStats();
                loadLeaderboard();
                return;
            }

            checkCollisions();

            if (penguin.y > 410 || penguin.x < 0) {
                gameOver();
                return;
            }
        }

        async function gameOver() {
            gameRunning = false;
            
            await sendGameTx('endGame');
            
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalJumps').textContent = `${jumpCount} jumps recorded on-chain`;
            document.getElementById('txConfirmed').textContent = `${confirmedTxCount} transactions confirmed`;
            document.getElementById('gameOverScreen').classList.remove('hidden');
            
            await loadPlayerStats();
            await loadLeaderboard();
        }

        function draw() {
            ctx.clearRect(0, 0, 700, 450);
            drawBackground();
            icebergs.forEach(drawIceberg);
            if (gameRunning || !document.getElementById('gameOverScreen').classList.contains('hidden')) {
                drawPenguin();
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        async function startGame() {
            if (!userAddress) {
                alert('Please connect your wallet first!');
                return;
            }

            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            initGame();
            
            await sendGameTx('startGame');
            
            gameRunning = true;
        }

        // ============ EVENT LISTENERS ============
        document.getElementById('connectBtn').addEventListener('click', connectWallet);
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('playAgainBtn').addEventListener('click', startGame);
        document.getElementById('sessionBtn').addEventListener('click', createSessionKey);
        canvas.addEventListener('click', jump);
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && gameRunning) {
                e.preventDefault();
                jump();
            }
        });

        // Initialize on load
        (async () => {
            // Try to load leaderboard and global stats without wallet connection
            try {
                await loadLeaderboard();
                await loadGlobalStats();
            } catch (e) {
                console.log('Could not load initial data');
            }
        })();

        // Initialize game
        initGame();
        gameLoop();
    </script>
</body>
</html>
